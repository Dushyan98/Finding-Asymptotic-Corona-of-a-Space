# -*- coding: utf-8 -*-
"""finding closed ultra filters

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CM6vr23Xn3-Rz-suOzv-OyvBt3Ihq9ZW
"""

#generating power set

import itertools

s ={1, 2, 3, 4}

def power_set(s):
  '''Generate the power set of a given set s.'''
  s_list = list(s) #convert the set to a list
  power_set = [] #initialize an empty set to store the power set
  for r in range(len(s_list) + 1): #Iterate over all possible subset sizes
    for subset in itertools.combinations(s_list, r): # generate commbinations of size r
      power_set.append(set(subset)) #Convert each combination (tuple) to a set and append
  return power_set #Return the complete power set

power_set_result = power_set(s)
print(power_set_result)

#defining closed subsets

def find_closed_subsets(s):
    """Find all closed subsets of set s in the discrete topology (every subset is closed)."""
    # In the discrete topology, every subset is closed
    closed_subsets = power_set(s)
    return closed_subsets

closed_subsets = find_closed_subsets(s)
print(closed_subsets)

#defining subsets

def find_subsets(s):
    """Generate all subsets of a given set s."""
    subsets = power_set(s)
    return subsets

subsets = find_subsets(s)
print(subsets)

#generating filters

def is_filter(subsets, s):
    """Check if a given subset is a filter according to the provided definition."""
    # Property 1: Non-empty set is not in the collection
    if frozenset() in subsets:
        return False

    # Property 2: If two sets are in the collection then their intersection should be in the collection
    for a in subsets:
        for b in subsets:
            if frozenset(a & b) not in subsets:
                return False

    # Property 3: If A is in the collection and A is a subset of B, then B should be in the collection
    for a in subsets:
        for b in power_set_result:
            if a.issubset(b) and frozenset(b) not in subsets:
                return False

    return True

def generate_filters(s):
    """Generate all filters for the given set s, up to a specified limit."""
    p_set = power_set(s)
    filters = []

    # Iterate through all possible subcollections of the power set
    for i in range(1, len(p_set) + 1):
        for subsets in itertools.combinations(p_set, i):
            subsets = {frozenset(x) for x in subsets}
            if is_filter(subsets, p_set):
                filters.append(subsets)
                #print(filters)
                #if limit and len(filters) >= limit:
                    #print(filters)
                    #return filters

    return filters


filters = generate_filters(s)

filters_list = []
for i, f in enumerate(filters):
    filters_list.append(f"F{i + 1}: {f}")

for filter_str in filters_list:
      print(filter_str)

s = {1, 2, 3, 4}

def generate_filters2(s, limit=None):
    """Generate all filters for the given set s, up to a specified limit."""
    p_set = power_set(s)
    filters2 = []

    # Iterate through all possible subcollections of the power set
    for i in range(1, len(p_set) + 1):
        for subsets in itertools.combinations(p_set, i):
            subsets = {frozenset(x) for x in subsets}
            if is_filter(subsets, p_set):
                filters2.append(subsets)
                print(filters2)
                filters2.clear()

    return filters2

filters2 = generate_filters2(s)

#finding subsets

def generate_subsets(s):
    """Generate all subsets of a given set s."""
    subsets = []
    # Generate subsets of all possible sizes
    for i in range(len(s) + 1):
        for subset in itertools.combinations(s, i):
            subsets.append(set(subset))

    return subsets

# Example usage
subsets = generate_subsets(s)
del subsets[0]
# Display all subsets
for i, subset in enumerate(subsets):
    print(f"Subset {i + 1}: {subset}")

print(subsets)

#creating a list from subsets

new = [list(item) for item in subsets]

converted_lists_subsets = new

print(converted_lists_subsets)

#finding closed subsets

#def find_closed_sets(s):
#    """Find all closed sets in the power set of space."""
#    p_set = power_set(s)
#    closed_sets = [subset for subset in p_set if find_closed_subset(s)]
#    return closed_sets

# Generate all closed sets for the set
#closed_sets = find_closed_sets(s)
#del closed_sets[0]
# Display the closed sets
#for i, cs in enumerate(closed_sets):
#    print(f"Closed Set {i + 1}: {cs}")

#creating a list from closed subsets

new = [list(item) for item in closed_subsets]

converted_lists_closed_subsets = new

print(converted_lists_closed_subsets)

#generating ultra filters

def is_ultra_filter(f, filters_list):
    """Check if a filter is an ultra filter."""
    for g in filters_list:
        if f != g and f.issubset(g):
            return False
    return True

def find_ultra_filters(s, limit=None):
    """Find all ultra filters for the given set s, up to a specified limit."""
    all_filters = generate_filters(s)
    ultra_filters = [f for f in all_filters if is_ultra_filter(f, all_filters)]
    return ultra_filters

ultra_filters = find_ultra_filters(s)


ultra_filters_list = []
for i, f in enumerate(ultra_filters):
    ultra_filters_list.append(f)

for filter_str in ultra_filters_list:
    print(filter_str)

#generating closed ultra filters

def is_closed_ultra_filter(f, ultra_filters_list):
    """Find all closed ultra filters for the given set s, up to a specified limit."""
    for f in ultra_filters_list:
        for h in f:
            if h not in closed_subsets:
                return False
    return True

def find_closed_ultra_filters(s):
    """Find all closed ultra filters for the given set s, up to a specified limit."""
    closed_ultra_filters = [f for f in ultra_filters if is_closed_ultra_filter(f, ultra_filters)]
    return closed_ultra_filters

closed_ultra_filters = find_closed_ultra_filters(s)


closed_ultra_filters_list = []
for i, f in enumerate(closed_ultra_filters):
    closed_ultra_filters_list.append(f)

for filter_str in closed_ultra_filters_list:
    print(filter_str)

#creating a dictionary for closed ultra filters

new = [list(item) for item in closed_ultra_filters_list]
#print(f"new: {new}")

# Function to convert each set in the nested lists to a list
def convert_sets_to_lists(nested_list):
    return [list(subset) for subset in nested_list]

# Apply the conversion function to each element in 'new'
converted_lists = [convert_sets_to_lists(item) for item in new]


# define list
dictionary_of_converted_lists = []
# Print the results
for i, converted in enumerate(converted_lists):
  data = {'name': f"CUF {i + 1}", 'converted_list': converted}
  dictionary_of_converted_lists.append(data)
  # print(f"CUF{i + 1}: {converted}")

print(converted_lists)
print()

for element in dictionary_of_converted_lists:
  print(element)

closed_ultra_filters_list = converted_lists

#selecting random subsets from a collection sets

import random

def A1(subsets):
    """Select two unique random elements from the list."""
    if len(subsets) < 2:
        raise ValueError("List must contain at least two elements")
    return random.sample(subsets, 1)
    if A1 == set():
        return random.sample(subsets, 1)

for x in A1(subsets):
  #print(f"A1 : {x}")
  break
# Example usage
#my_list = subsets
#random_elements = A1(my_list)

#print(f"A1: {random_elements}")

def A2(subsets):
    """Select two unique random elements from the list."""
    if len(subsets) < 2:
        raise ValueError("List must contain at least two elements")
    return random.sample(subsets, 1)
    if A1 == A2 and A2 == set():
        return random.sample(subsets, 1)

for x in A2(subsets):
  #print(f"A2 : {x}")
  break
# Example usage
#my_list = subsets
#random_elements = A2(my_list)

#print(f"A2: {random_elements}")
# Assuming A1 and A2 are functions that return sets within lists
new_A1 = A1(subsets)
new_A2 = A2(subsets)
print(f"new_A1: {new_A1}")
print(f"new_A2: {new_A2}")

# Convert sets within the lists to lists
list_new_A1 = [list(item) for item in new_A1]
list_new_A2 = [list(item) for item in new_A2]

print(f"list_new_A1: {list_new_A1}")
print(f"list_new_A2: {list_new_A2}")

# Convert the result of A1(subsets) to a list directly
list_A1_subsets = list(list_new_A1)[0]  # Extract the first item if A1(subsets) returns a list with a single set
list_A1_subsets = list(list_A1_subsets)  # Convert the set to a list

print(f"list_A1_subsets: {list_A1_subsets}")

# Convert the result of A2(subsets) to a list directly
list_A2_subsets = list(list_new_A2)[0]  # Extract the first item if A2(subsets) returns a list with a single set
list_A2_subsets = list(list_A2_subsets)  # Convert the set to a list

print(f"list_A2_subsets: {list_A2_subsets}")

#definin haudorff distance

import numpy as np
import itertools

def euclidean_distance(point1, point2):
    """Calculate the Euclidean distance between two points."""
    return np.linalg.norm(np.array(point1) - np.array(point2))

def hausdorff_distance(list_A1_subsets, list_A2_subsets):
    """Calculate the Hausdorff distance between two sets."""
    def max_min_distance(list_A1_subsets, list_A2_subsets):
        max_distance = 0
        for point1 in list_A1_subsets:
            min_distance = float('inf')
            for point2 in list_A2_subsets:
                distance = euclidean_distance(point1, point2)
                if distance < min_distance:
                    min_distance = distance
            if min_distance > max_distance:
                max_distance = min_distance
        return max_distance

    distance_A1A2 = max_min_distance(list_A1_subsets, list_A2_subsets)
    distance_A2A1 = max_min_distance(list_A2_subsets, list_A1_subsets)

    return max(distance_A1A2, distance_A2A1)



distance = hausdorff_distance(list_A1_subsets, list_A2_subsets)
print(f"Hausdorff distance: {distance}")

#defining the asymptotic alike

def are_asymptotically_alike(list_A1_subsets, list_A2_subsets):
    """Check if two sets are asymptotically alike (Hausdorff distance is finite)."""
    distance = hausdorff_distance(list_A1_subsets, list_A2_subsets)
    if distance < float('inf'):
        return True
    return False

if are_asymptotically_alike(list_A1_subsets, list_A2_subsets):
    print(f"Sets A1 and A2 are asymptotically alike (Hausdorff distance is finite).")
else:
    print(f"Sets A1 and A2 are not asymptotically alike (Hausdorff distance is infinite).")

#defining unboundedness

def is_unbounded(list_A1_subsets, space, threshold=1e6):
    """
    Check if a subset is unbounded in a given metric space.
    We use a large threshold as an approximation for unboundedness.
    """
    for point in space:
        bounded = True
        for element in list_A1_subsets:
            if euclidean_distance(point, element) > threshold:
                bounded = False
                break
        if bounded:
            return False
    return True

# Example usage:


if is_unbounded(list_A1_subsets, s):
    print("The subset A1 is unbounded.")
else:
    print("The subset A1 is bounded.")

def is_unbounded(list_A2_subsets, space, threshold=1e6):
    """
    Check if a subset is unbounded in a given metric space.
    We use a large threshold as an approximation for unboundedness.
    """
    for point in space:
        bounded = True
        for element in list_A2_subsets:
            if euclidean_distance(point, element) > threshold:
                bounded = False
                break
        if bounded:
            return False
    return True

# Example usage:


if is_unbounded(list_A2_subsets, s):
    print("The subset A2 is unbounded.")
else:
    print("The subset A2 is bounded.")

#finding unbounded sets

def generate_unbounded_subsets(list_A1_subsets, s):
    """Generate all unbounded subsets from a given subset."""
    unbounded_subsets = []
    for size in range(1, len(list_A1_subsets) + 1):
        for combination in itertools.combinations(list_A1_subsets, size):
            if is_unbounded(combination, s):
                unbounded_subsets.append(set(combination))
    return unbounded_subsets

unbounded_subsets = generate_unbounded_subsets(list_A1_subsets, s)

unbounded_subsets_list = []
for us in enumerate(unbounded_subsets):
    unbounded_subsets_list.append(list(us))
for i, unbounded_subsets in unbounded_subsets_list:
    print(f"unbounded_subset_of_A1 {i + 1}: {unbounded_subsets}")

def generate_unbounded_subsets(list_A2_subsets, s):
    """Generate all unbounded subsets from a given subset."""
    unbounded_subsets = []
    for size in range(1, len(list_A2_subsets) + 1):
        for combination in itertools.combinations(list_A2_subsets, size):
            if is_unbounded(combination, s):
                unbounded_subsets.append(set(combination))
    return unbounded_subsets

unbounded_subsets = generate_unbounded_subsets(list_A2_subsets, s)

unbounded_subsets_list = []
for us in enumerate(unbounded_subsets):
    unbounded_subsets_list.append(list(us))
for i, unbounded_subsets in unbounded_subsets_list:
    print(f"unbounded_subset_of_A2 {i + 1}: {unbounded_subsets}")

#defining the bounded to check the boundedness

def is_bounded(list_A1_subsets, s, threshold=1e6):
    """
    Check if a subset is unbounded in a given metric space.
    We use a large threshold as an approximation for unboundedness.
    """
    for point in s:
        unbounded = True
        for element in list_A1_subsets:
            if euclidean_distance(point, element) < threshold:
                unbounded = False
                break
        if unbounded:
            return False
    return True

# Example usage:


if is_bounded(list_A1_subsets, s):
    print("The subset A1 is bounded.")
else:
    print("The subset A1 is unbounded.")

def is_bounded(list_A2_subsets, s, threshold=1e6):
    """
    Check if a subset is unbounded in a given metric space.
    We use a large threshold as an approximation for unboundedness.
    """
    for point in s:
        unbounded = True
        for element in list_A2_subsets:
            if euclidean_distance(point, element) < threshold:
                unbounded = False
                break
        if unbounded:
            return False
    return True

# Example usage:


if is_bounded(list_A2_subsets, s):
    print("The subset A2 is bounded.")
else:
    print("The subset A2 is unbounded.")

#finfing bounded subsets of a set

def generate_bounded_subsets(list_A1_subsets, s):
    """Generate all unbounded subsets from a given subset."""
    bounded_subsets = []
    for size in range(1, len(list_A1_subsets) + 1):
        for combination in itertools.combinations(list_A1_subsets, size):
            if is_bounded(combination, s):
                bounded_subsets.append(set(combination))
    return bounded_subsets

bounded_subsets = generate_bounded_subsets(list_A1_subsets, s)

bounded_subsets_list = []
for bs in enumerate(bounded_subsets):
    bounded_subsets_list.append(list(bs))
for i, bounded_subsets in bounded_subsets_list:
    print(f"bounded_subset_of_A1 {i + 1}: {bounded_subsets}")

def generate_bounded_subsets(list_A2_subsets, s):
    """Generate all unbounded subsets from a given subset."""
    bounded_subsets = []
    for size in range(1, len(list_A2_subsets) + 1):
        for combination in itertools.combinations(list_A2_subsets, size):
            if is_bounded(combination, s):
                bounded_subsets.append(set(combination))
    return bounded_subsets

bounded_subsets = generate_bounded_subsets(list_A2_subsets, s)

bounded_subsets_list = []
for bs in enumerate(bounded_subsets):
    bounded_subsets_list.append(list(bs))
for i, bounded_subsets in bounded_subsets_list:
    print(f"bounded_subset_of_A2 {i + 1}: {bounded_subsets}")

#defining the asymptotic disjointness

def are_asymptotically_disjoint(list_A1_subsets, list_A2_subsets, s):
    """Check if two subsets A1 and A2 are asymptotically disjoint."""
    unbounded_A1 = generate_unbounded_subsets(list_A1_subsets, s)
    unbounded_A2 = generate_unbounded_subsets(list_A2_subsets, s)
    for L1 in unbounded_A1:
      for L2 in unbounded_A2:
        distance = hausdorff_distance(L1, L2)
        if distance < float('inf'):
          #print("The subsets A1 and A2 are not asymptotically disjoint.")
          return False

    #print("The subsets A1 and A2 are asymptotically disjoint.")


if are_asymptotically_disjoint(list_A1_subsets, list_A2_subsets, s):
    print("The subsets A1 and A2 are asymptotically disjoint.")
else:
    print("The subsets A1 and A2 are not asymptotically disjoint.")

#defining the relativity within the sets

def are_related_sets(list_A1_subsets, list_A2_subsets):
    """Check if two sets A and B are related."""
    if list_A1_subsets == list_A2_subsets:
        return True
    if is_unbounded(list_A1_subsets, s) and is_unbounded(list_A2_subsets, s):
        if hausdorff_distance(list_A1_subsets, list_A2_subsets) < float('inf'):
            return True
    return False

if are_related_sets(list_A1_subsets, list_A2_subsets):
    print("Sets A1 and A2 are related.")
else:
    print("Sets A1 and A2 are not related.")

#selecting random closed ultra filters

import random

def new_F1(closed_ultra_filters_list):
    """Select two unique random elements from the list."""
    if len(closed_ultra_filters_list) < 2:
        raise ValueError("List must contain at least two elements")
    return random.sample(closed_ultra_filters_list, 1)
    if new_F1 == set():
        return random.sample(closed_ultra_filters_list, 1)

for y in new_F1(closed_ultra_filters_list):
  #print(f"A1 : {x}")
  break
# Example usage
#my_list = subsets
#random_elements = A1(my_list)

#print(f"A1: {random_elements}")

def new_F2(closed_ultra_filters_list):
    """Select two unique random elements from the list."""
    if len(closed_ultra_filters_list) < 2:
        raise ValueError("List must contain at least two elements")
    return random.sample(closed_ultra_filters_list, 1)
    if new_F1 == new_f2 and new_F2 == set():
        return random.sample(closed_ultra_filters_list, 1)

for x in new_F2(closed_ultra_filters_list):
  #print(f"A2 : {x}")
  break
# Example usage
#my_list = subsets
#random_elements = A2(my_list)

#print(f"A2: {random_elements}")
# Assuming A1 and A2 are functions that return sets within lists
new2_F1 = new_F1(closed_ultra_filters_list)
new2_F2 = new_F2(closed_ultra_filters_list)
print(f"new2_F1: {new2_F1}")
print(f"new2_F2: {new2_F2}")

# Convert sets within the lists to lists
new3_F1 = [list(item) for item in new2_F1]
new3_F2 = [list(item) for item in new2_F2]

print(f"list_new_A1: {new3_F1}")
print(f"list_new_A2: {new3_F2}")

# Convert the result of A1(subsets) to a list directly
F1 = list(new3_F1)[0]  # Extract the first item if A1(subsets) returns a list with a single set
F1 = list(F1)  # Convert the set to a list

print(f"F1: {F1}")

# Convert the result of A2(subsets) to a list directly
F2 = list(new3_F2)[0]  # Extract the first item if A2(subsets) returns a list with a single set
F2 = list(F2)  # Convert the set to a list

print(f"F2: {F2}")

#defining the relativity within ultrafilters

def are_related_ultrafilters(F1, F2, space):
    """Check if two closed ultrafilters F1 and F2 are related."""
    for A in F1:
        for B in F2:
            subsets_A = generate_subsets(A)
            subsets_B = generate_subsets(B)
            #print(f"subsets_A: {subsets_A}")
            #print(f"subsets_B: {subsets_B}")
            related_found = False
            for L1 in subsets_A:
                for L2 in subsets_B:
                    if are_related_sets(L1, L2,):
                        related_found = True
                        break
                #if related_found:
                 # break
                    if not related_found:
                      return False

            if not related_found:
              #print("The closed ultrafilters F1 and F2 are not related.")
              break

    #print("The closed ultrafilters F1 and F2 are related.")
    return True


if are_related_ultrafilters(F1, F2, s):
    print("The closed ultrafilters F1 and F2 are related.")
else:
    print("The closed ultrafilters F1 and F2 are not related.")

#defining the sigma function and finding values

def sigma(x, closed_sets):
    """Map each point x to the family of closed subsets containing x."""
    return [closed_set for closed_set in closed_sets if x in closed_set]

# Example usage
space = s
closed_subsets = find_closed_subsets(s)

sigma_map = {x: sigma(x, closed_subsets) for x in s}

collection_of_sigma = []  # Initialize an empty list to store the sigma maps
for point, closed_families in sigma_map.items():
    collection_of_sigma.append(closed_families)  # Append the sigma map to the list

print(collection_of_sigma)

#making the dictionary for equivalence classes

new = [list(item) for item in collection_of_sigma]
#print(f"new: {new}")

# Function to convert each set in the nested lists to a list
def convert_sets_to_lists_equivalence(nested_list):
    return [list(subset) for subset in nested_list]

# Apply the conversion function to each element in 'new'
converted_lists_equivalence = [convert_sets_to_lists_equivalence(item) for item in new]


# define list
dictionary_of_converted_lists_equivalence = []
# Print the results
for i, converted in enumerate(converted_lists_equivalence):
  data = {'name': f"Sigma {i + 1}", 'converted_list_equivalence': converted}
  dictionary_of_converted_lists_equivalence.append(data)
  # print(f"CUF{i + 1}: {converted}")

for element in dictionary_of_converted_lists_equivalence:
  print(element)
#print(dictionary_of_converted_lists_equivalence)

print(converted_lists_equivalence)

#finding equivalence classes

def find_equivalence_classes(converted_lists_equivalence):
  equivalence_classes = []
  for i, sigma1 in enumerate(converted_lists_equivalence):
  #for sigma1 in converted_lists_equivalence:
    for sigma2 in converted_lists_equivalence:
      if are_related_sets(sigma1, sigma2):
        equivalence_classes.append(sigma2)

  return equivalence_classes

equivalence_classes = find_equivalence_classes(converted_lists_equivalence)

print(equivalence_classes)

def find_equivalence_classes2(converted_lists_equivalence):
  equivalence_classes2 = []
  for i, sigma1 in enumerate(converted_lists_equivalence):
  #for sigma1 in converted_lists_equivalence:
    for sigma2 in converted_lists_equivalence:
      if are_related_sets(sigma1, sigma2):
        equivalence_classes2.append(sigma2)

    name = []

    for result in equivalence_classes2:
        for converted_list in dictionary_of_converted_lists_equivalence:
          if result == converted_list['converted_list_equivalence']:
            name.append(converted_list['name'])


    print(f'eq_class CUF {i+1}: {name}')
    equivalence_classes2.clear()
  return equivalence_classes2

equivalence_classes = find_equivalence_classes(converted_lists_equivalence)

#defining the function

def f(converted_lists_equivalence):
  value_f = []
  for x in s:
    value_f.append(sigma(x, closed_subsets))

  return value_f

value_f = f(converted_lists_equivalence)

print(value_f)
#or i, vf in enumerate(value_f, 1):
#    print(f"f({i}) : {vf}")

#arranging of the results according to the relevant element

def f(converted_lists_equivalence):
  value_f2 = []
  for x in s:
    value_f2.append(sigma(x, closed_subsets))
    print(f'f({x}) : {value_f2}')
    value_f2.clear()

  return value_f2

value_f2 = f(converted_lists_equivalence)

#finding injectivity of a function

def is_injective(f):
  for i, j in range(0, len(value_f)):
    for value_f[i], value_f[j] in value_f:
      if value_f[i] == value_f[j] and i != j:
        return False
    return True

if is_injective:
  print("f is injective")
else:
  print("f is not injective")

#defining and finding of asymptotically normality of a space

def is_asymptotically_normal(s):
    """Check if the space X is asymptotically normal."""
    for subset1 in converted_lists_subsets:
      for subset2 in converted_lists_subsets:
        if subset1 != subset2:
          if are_asymptotically_disjoint(subset1, subset2, s):
            # Try to find X1 and X2
            for X1, X2 in power_set(s):
              if X2 == s - X1:
                if not are_asymptotically_disjoint(subset1, X1) or not are_asymptotically_disjoint(subset2, X2):
                  return False
                  return

                else :
                  return True


if is_asymptotically_normal(s):
    print("The space X is asymptotically normal.")
else:
    print("The space X is not asymptotically normal.")

#finding related closed ultra filters

def find_related_closed_ultra_filters(closed_ultra_filters_list):
  related_closed_ultra_filters = []
  for f1 in closed_ultra_filters_list:
    for f2 in closed_ultra_filters_list:
      if are_related_ultrafilters(f1, f2, s):
        if f1 != f2:
          related_closed_ultra_filters.append((f1, f2))

  return related_closed_ultra_filters

related_closed_ultra_filters = find_related_closed_ultra_filters(closed_ultra_filters_list)

# Example results in the form of element labels
results = related_closed_ultra_filters

print(results)
print()

for result in results:
    for element in result:
      for converted_list in dictionary_of_converted_lists:
        if element == converted_list['converted_list']:
          print(converted_list['name'])
    print()  # Empty line for separation

#finding all related closed ultra filters

def find_all_related_closed_ultra_filters(closed_ultra_filters_list):
  all_related_closed_ultra_filters = []
  related_found = False
  #for i, f1 in enumerate(closed_ultra_filters_list):
  for f1 in closed_ultra_filters_list:
    for f2 in closed_ultra_filters_list:
        if are_related_ultrafilters(f1, f2, s):
          related_found =True
          all_related_closed_ultra_filters.append(f2)

        elif not related_found:
          break


  return all_related_closed_ultra_filters

all_related_closed_ultra_filters = find_all_related_closed_ultra_filters(closed_ultra_filters_list)

print(all_related_closed_ultra_filters)

#removing duplicate items from list of all related closed ultra filters

all_unique_related_closed_ultra_filters = []
for item in all_related_closed_ultra_filters:
    if item not in all_unique_related_closed_ultra_filters:
        all_unique_related_closed_ultra_filters.append(item)

print(all_unique_related_closed_ultra_filters)

#finding equivalent classes of all related closed ultra filters

def find_all_related_closed_ultra_filters2(closed_ultra_filters_list):
  all_related_closed_ultra_filters2 = []
  related_found = False
  for i, f1 in enumerate(closed_ultra_filters_list):
  #for f1 in closed_ultra_filters_list:
    for f2 in closed_ultra_filters_list:
        if are_related_ultrafilters(f1, f2, s):
          related_found =True
          all_related_closed_ultra_filters2.append(f2)

        elif not related_found:
          break

    name = []

    for result in all_related_closed_ultra_filters2:
        for converted_list in dictionary_of_converted_lists:
          if result == converted_list['converted_list']:
            name.append(converted_list['name'])


    print(f'eq_class CUF {i+1}: {name}')
    all_related_closed_ultra_filters2.clear()

    #for i in range(0, len(closed_ultra_filters_list)):

          #all_related_closed_ultra_filters.clear()

  return all_related_closed_ultra_filters2

all_related_closed_ultra_filters2 = find_all_related_closed_ultra_filters2(closed_ultra_filters_list)

#defining asymptotic corona

def asymptotic_corona(all_unique_related_closed_ultra_filters, equivalence_classes, s):
  result = []

  for filters in all_unique_related_closed_ultra_filters:
    for eq_classes in equivalence_classes:
      in_equivalence_class = False
      for filter in filters:
        for eq_class in eq_classes:
          if filter == eq_class:
            in_equivalence_class = True
            break
        if in_equivalence_class:
          break
      if not in_equivalence_class:
        result.append(filters)

  return result

result_corona = asymptotic_corona(all_unique_related_closed_ultra_filters, equivalence_classes, s)
#print(f'asymptotic corona : {result_corona}')

print("asymptotic corona :")
print()

# Example results in the form of element labels
for result in result_corona:
    for converted_list in dictionary_of_converted_lists:
      if result == converted_list['converted_list']:
        print(converted_list['name'])
    print()  # Empty line for separation